# TOON 2.0 Grammar (EBNF)

This document defines the TOON grammar in Extended Backus-Naur Form for parser implementation.

## Lexical Grammar

### Tokens

```ebnf
(* Structural Tokens *)
COLON           ::= ':'
COMMA           ::= ','
PIPE            ::= '|'
HTAB            ::= #x0009        (* Horizontal tab *)
LBRACKET        ::= '['
RBRACKET        ::= ']'
LBRACE          ::= '{'
RBRACE          ::= '}'
HYPHEN          ::= '-'
NEWLINE         ::= #x000A        (* Line feed *)
SPACE           ::= #x0020        (* ASCII space *)

(* Primitives *)
NULL            ::= 'null'
TRUE            ::= 'true'
FALSE           ::= 'false'
BOOLEAN         ::= TRUE | FALSE

(* Numbers *)
DIGIT           ::= [0-9]
DIGIT1_9        ::= [1-9]
INTEGER         ::= '0' | DIGIT1_9 DIGIT*
FRACTION        ::= '.' DIGIT+
EXPONENT        ::= [eE] [+-]? DIGIT+
NUMBER          ::= '-'? INTEGER FRACTION? EXPONENT?

(* Strings *)
ESCAPE          ::= '\\' | '\"' | '\n' | '\r' | '\t'
STRING_CHAR     ::= [^"\\\u0000-\u001F] | ESCAPE
QUOTED_STRING   ::= '"' STRING_CHAR* '"'
UNQUOTED_CHAR   ::= [^:\[\]{},"|\\\u0000-\u001F\-#]
                  | '-' [^ ]              (* Hyphen not followed by space *)
UNQUOTED_STRING ::= UNQUOTED_CHAR+        (* Subject to semantic quoting rules *)

(* Identifiers *)
ID_START        ::= [A-Za-z_]
ID_CONTINUE     ::= [A-Za-z0-9_.]
IDENTIFIER      ::= ID_START ID_CONTINUE*

(* Values *)
STRING          ::= QUOTED_STRING | UNQUOTED_STRING
VALUE           ::= STRING | NUMBER | BOOLEAN | NULL

(* Indentation *)
INDENT          ::= SPACE+                (* Must be multiple of indentSize *)
```

## Syntactic Grammar

### Document Structure

```ebnf
document        ::= root_value EOF

root_value      ::= root_array
                  | root_object
                  | root_primitive
                  | empty

empty           ::= (NEWLINE | SPACE)*

root_array      ::= array_header array_content

root_primitive  ::= VALUE NEWLINE?

root_object     ::= object_content
```

### Objects

```ebnf
object_content  ::= object_field*

object_field    ::= simple_field
                  | nested_object_field
                  | array_field

simple_field    ::= INDENT* key COLON SPACE VALUE NEWLINE

nested_object_field ::= INDENT* key COLON NEWLINE
                        INDENT object_content DEDENT

array_field     ::= INDENT* array_header array_content

key             ::= IDENTIFIER | QUOTED_STRING | dotted_key

dotted_key      ::= IDENTIFIER ('.' IDENTIFIER)+
```

### Arrays

```ebnf
array_header    ::= key? LBRACKET NUMBER delimiter_marker? RBRACKET field_list? COLON NEWLINE

delimiter_marker ::= HTAB | PIPE

field_list      ::= LBRACE field_name (delimiter field_name)* RBRACE

field_name      ::= IDENTIFIER | QUOTED_STRING

delimiter       ::= COMMA | HTAB | PIPE    (* Context-dependent on marker *)

array_content   ::= inline_array
                  | tabular_array
                  | list_array
                  | array_of_arrays
                  | empty_array

empty_array     ::= (* no content after header *)
```

### Array Format 1: Inline Primitive Arrays

```ebnf
inline_array    ::= INDENT VALUE (delimiter VALUE)* NEWLINE
```

Example:
```
tags[3]: a,b,c
```

### Array Format 2: Tabular Arrays

```ebnf
tabular_array   ::= tabular_row+

tabular_row     ::= INDENT VALUE (delimiter VALUE)* NEWLINE

(* Number of values per row MUST match field_list count *)
```

Example:
```
users[2]{id,name}:
  1,Alice
  2,Bob
```

### Array Format 3: List Arrays

```ebnf
list_array      ::= list_item+

list_item       ::= INDENT HYPHEN SPACE list_item_content NEWLINE

list_item_content ::= primitive_item
                    | object_item
                    | array_item

primitive_item  ::= VALUE

object_item     ::= key COLON SPACE VALUE NEWLINE
                   (INDENT SPACE object_field)* DEDENT

array_item      ::= array_header array_content
```

Example:
```
items[2]:
  - id: 1
    name: First
  - id: 2
    name: Second
```

### Array Format 4: Arrays of Arrays

```ebnf
array_of_arrays ::= nested_array+

nested_array    ::= INDENT HYPHEN SPACE array_header array_content
```

Example:
```
matrix[2]:
  - [2]: 1,2
  - [2]: 3,4
```

## Indentation Rules

The grammar above uses pseudo-tokens `INDENT` and `DEDENT` which are generated by the lexer's indentation tracker:

```
Indentation State Machine:

current_indent = 0
indent_stack = [0]

On NEWLINE:
  count leading SPACE characters â†’ new_indent

  if new_indent > current_indent:
    emit INDENT
    push new_indent onto indent_stack
    current_indent = new_indent

  elif new_indent < current_indent:
    while new_indent < indent_stack.top():
      emit DEDENT
      pop indent_stack
      current_indent = indent_stack.top()

    if new_indent != current_indent:
      ERROR: invalid dedent level

  else:
    emit SAME_INDENT
```

## Context-Sensitive Rules

### Active Delimiter

The delimiter used for splitting values depends on context:

```
delimiter_context_stack = [COMMA]  (* Document default *)

On array_header with delimiter_marker:
  if HTAB in header:
    push HTAB onto delimiter_context_stack
  elif PIPE in header:
    push PIPE onto delimiter_context_stack
  else:
    push COMMA onto delimiter_context_stack

On array_end:
  pop delimiter_context_stack

Current active delimiter = delimiter_context_stack.top()
```

### Quoting Rules (Semantic)

These rules are enforced during lexing/parsing, not in the BNF:

```
must_quote(string) :=
  string is empty
  OR string has leading/trailing whitespace
  OR string in {"true", "false", "null"}
  OR string matches NUMBER pattern
  OR string contains any of: : " \ [ ] { } control-chars
  OR string contains active_delimiter
  OR string == "-"
  OR string starts with "- "
  OR string starts with "#"

unquoted_string is valid only if !must_quote(unquoted_string)
```

## Array Format Selection (Generator)

When generating arrays, choose format based on content analysis:

```
select_array_format(array):
  if array is empty:
    return EMPTY

  if all elements are primitives:
    return INLINE

  if all elements are objects:
    if all objects have identical keys:
      if all values in all objects are primitives:
        return TABULAR

  return LIST
```

## Grammar Extensions

### Key Folding (Optional Feature)

```ebnf
dotted_key      ::= key_segment ('.' key_segment)+

key_segment     ::= IDENTIFIER  (* Must match ^[A-Za-z_][A-Za-z0-9_]*$ *)
```

Used to collapse single-key chains:
```
data.metadata.value: 42
```

Equivalent to:
```
data:
  metadata:
    value: 42
```

## Productions for Streaming Parser

For streaming implementation, we need productions that can be evaluated left-to-right with bounded lookahead:

### Lookahead Requirements

| Context | Lookahead Needed | Reason |
|---------|------------------|--------|
| `key:` vs `key: value` | 1 token after `:` | Distinguish object start vs simple field |
| `[N]` vs `[N]:` | 1 token after `]` | Distinguish array reference vs declaration |
| Tabular vs list array | See array content | First item determines format |
| Root form | First line | Determine if array header, primitive, or object |

### Key Productions for Parser Implementation

```
parseDocument():
  first_line = peek first non-empty line
  if first_line matches array_header:
    return parseRootArray()
  elif document has exactly one non-empty line && !is_key_value(line):
    return parseRootPrimitive()
  else:
    return parseRootObject()

parseObject():
  while current_indent >= expected_indent:
    key = parseKey()
    expect(COLON)
    if peek() == NEWLINE:
      parseNestedObject()
    elif peek() == LBRACKET:
      parseArrayField()
    else:
      parseSimpleField()

parseArray():
  header = parseArrayHeader()
  set active_delimiter from header

  peek at first content line
  if first_content matches INDENT VALUE delimiter:
    if header has field_list:
      return parseTabularArray()
    else:
      return parseInlineArray()
  elif first_content matches INDENT HYPHEN:
    return parseListArray()
  else:
    return parseEmptyArray()

parseTabularArray():
  fields = header.field_list
  for each row:
    row_values = split(line, active_delimiter)
    if row_values.length != fields.length:
      ERROR: width mismatch
    emit_object(zip(fields, row_values))

parseListArray():
  while peek() == HYPHEN:
    consume(HYPHEN)
    if peek() == LBRACKET:
      parseNestedArray()
    elif peek() == key COLON:
      parseObjectItem()
    else:
      parsePrimitiveItem()
```

## Error Productions

The parser should recognize these error conditions:

```
ERROR: Length mismatch
  declared_length in [N] != actual_item_count

ERROR: Width mismatch (tabular)
  row_value_count != field_list.length

ERROR: Missing colon
  key not followed by ':'

ERROR: Invalid escape
  '\\' followed by char not in {\\, ", n, r, t}

ERROR: Unterminated string
  '"' without matching closing '"'

ERROR: Invalid indentation
  indent_level % indent_size != 0

ERROR: Tab in indentation
  HTAB character used for indentation

ERROR: Invalid dedent
  dedent to level not in indent_stack

ERROR: Blank line in array
  empty line within array content
```

## Summary

This grammar captures TOON's key features:
- Line-oriented structure with significant indentation
- Context-sensitive delimiters
- Multiple array formats with headers
- Optional key folding
- Minimal quoting with semantic rules

The grammar is designed for LL(1) parsing with bounded lookahead, suitable for streaming implementation in Jackson's token-based architecture.
